// Подключаем заголовочный файл класса Graph
#include "Graph.h"
// Подключаем заголовочный файл визуализатора с RayLib
#include "GraphVisualizerRaylib.h"
// Подключаем библиотеку для ввода-вывода
#include <iostream>
// Подключаем библиотеку для работы со строками
#include <string>

// Используем пространство имён std для упрощения кода
// Теперь можем писать cout вместо std::cout, string вместо std::string и т.д.
using namespace std;

/**
 * Главная программа для визуализации неориентированных графов с RayLib
 * Лабораторная работа 5: Графы
 * 
 * Программа позволяет:
 * - Создавать различные типы графов (простой, полный, цикл, двудольный, несвязный)
 * - Загружать графы из файла
 * - Визуализировать графы с автоматической оптимизацией расположения вершин
 * - Выполнять алгоритмы обхода (DFS, BFS)
 * - Анализировать свойства графов (связность, компоненты связности)
 */

// Главная функция программы - точка входа
int main() {
    // ===== ОБЪЯВЛЕНИЕ ВСПОМОГАТЕЛЬНЫХ ФУНКЦИЙ ВНУТРИ MAIN =====
    
    // Лямбда-функция для вывода меню
    // [&] означает захват всех внешних переменных по ссылке
    auto printMenu = []() {
        // Выводим красивое меню с разделителями
        cout << "\n========================================" << endl;
        cout << "   ВИЗУАЛИЗАЦИЯ ГРАФОВ - LAB 5" << endl;
        cout << "         (версия RayLib)" << endl;
        cout << "========================================" << endl;
        // Список доступных опций
        cout << "1. Простой граф (треугольник)" << endl;
        cout << "2. Полный граф K5" << endl;
        cout << "3. Граф-цикл (6 вершин)" << endl;
        cout << "4. Двудольный граф" << endl;
        cout << "5. Несвязный граф" << endl;
        cout << "6. Загрузить граф из файла" << endl;
        cout << "0. Выход" << endl;
        cout << "========================================" << endl;
        cout << "Выберите опцию: ";
    };
    
    // Функция создания простого графа-треугольника
    // Граф из 3 вершин, соединённых в треугольник
    auto createSimpleGraph = []() -> Graph {
        Graph g(3);        // Создаём граф с 3 вершинами
        g.addEdge(0, 1);   // Соединяем вершины 0 и 1
        g.addEdge(1, 2);   // Соединяем вершины 1 и 2
        g.addEdge(2, 0);   // Соединяем вершины 2 и 0 (замыкаем треугольник)
        return g;          // Возвращаем созданный граф
    };
    
    // Функция создания полного графа K5
    // Полный граф - каждая вершина соединена со всеми остальными
    auto createCompleteGraph = []() -> Graph {
        Graph g(5);  // Создаём граф с 5 вершинами
        // Двойной цикл для соединения всех пар вершин
        for (int i = 0; i < 5; i++) {
            for (int j = i + 1; j < 5; j++) {  // j начинается с i+1 чтобы не дублировать рёбра
                g.addEdge(i, j);  // Добавляем ребро между i и j
            }
        }
        return g;
    };
    
    // Функция создания графа-цикла
    // Вершины соединены в замкнутое кольцо
    auto createCycleGraph = []() -> Graph {
        Graph g(6);  // Создаём граф с 6 вершинами
        // Соединяем каждую вершину со следующей
        for (int i = 0; i < 6; i++) {
            g.addEdge(i, (i + 1) % 6);  // % 6 для замыкания цикла (5 соединяется с 0)
        }
        return g;
    };
    
    // Функция создания двудольного графа
    // Двудольный граф - вершины разделены на две группы,
    // рёбра соединяют только вершины из разных групп
    auto createBipartiteGraph = []() -> Graph {
        Graph g(8);  // Создаём граф с 8 вершинами
        // Первая доля: вершины 0, 1, 2, 3
        // Вторая доля: вершины 4, 5, 6, 7
        for (int i = 0; i < 4; i++) {          // Проходим по первой доле
            for (int j = 4; j < 8; j++) {      // Проходим по второй доле
                if ((i + j) % 2 == 0) {        // Соединяем через одну (для красоты)
                    g.addEdge(i, j);           // Добавляем ребро между долями
                }
            }
        }
        return g;
    };
    
    // Функция создания несвязного графа
    // Несвязный граф состоит из нескольких отдельных компонент
    auto createDisconnectedGraph = []() -> Graph {
        Graph g(9);  // Создаём граф с 9 вершинами
        
        // Первая компонента связности - треугольник (вершины 0, 1, 2)
        g.addEdge(0, 1);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        
        // Вторая компонента связности - цепочка (вершины 3, 4, 5)
        g.addEdge(3, 4);
        g.addEdge(4, 5);
        
        // Третья компонента связности - треугольник (вершины 6, 7, 8)
        g.addEdge(6, 7);
        g.addEdge(7, 8);
        g.addEdge(8, 6);
        
        return g;
    };
    
    // Функция демонстрации алгоритмов на графе
    // Выводит информацию о графе и результаты обходов
    auto demonstrateGraphAlgorithms = [](const Graph& graph) {
        cout << "\n=== Демонстрация алгоритмов ===" << endl;
        
        // Выводим общую информацию о графе
        graph.printInfo();
        
        // Выполняем алгоритмы обхода, если граф не пуст
        if (graph.getNumVertices() > 0) {
            // Обход в глубину (DFS - Depth First Search)
            cout << "\nОбход в глубину (DFS) от вершины 0: ";
            auto dfs = graph.depthFirstSearch(0);  // Запускаем DFS от вершины 0
            for (int v : dfs) {                    // Выводим порядок посещения вершин
                cout << v << " ";
            }
            cout << endl;
            
            // Обход в ширину (BFS - Breadth First Search)
            cout << "Обход в ширину (BFS) от вершины 0: ";
            auto bfs = graph.breadthFirstSearch(0);  // Запускаем BFS от вершины 0
            for (int v : bfs) {                      // Выводим порядок посещения вершин
                cout << v << " ";
            }
            cout << endl;
        }
    };
    
    // Функция визуализации графа
    // Создаёт окно RayLib и отображает граф
    auto visualizeGraph = [](const Graph& graph) {
        // Создаём объект визуализатора с заданными размерами окна
        GraphVisualizerRaylib visualizer(graph, 1200, 800);
        
        // Настройка цветовой схемы (RayLib имеет встроенные константы цветов)
        visualizer.setVertexColor(SKYBLUE);      // Небесно-голубой цвет вершин
        visualizer.setEdgeColor(DARKGRAY);       // Тёмно-серый цвет рёбер
        visualizer.setTextColor(WHITE);          // Белый цвет текста
        visualizer.setBackgroundColor(RAYWHITE); // Светлый фон
        
        // Применяем алгоритм оптимизации расположения вершин
        cout << "\nПрименение алгоритма оптимизации расположения вершин..." << endl;
        visualizer.optimize(500);  // Выполняем 500 итераций оптимизации
        
        // Выводим инструкции по управлению
        cout << "\n=== Управление ===" << endl;
        cout << "Пробел - включить/выключить оптимизацию в реальном времени" << endl;
        cout << "R - сбросить позиции вершин" << endl;
        cout << "C - центрировать граф" << endl;
        cout << "ESC или закрыть окно - выход" << endl;
        cout << "\nОткрывается окно визуализации..." << endl;
        
        // Запускаем интерактивное отображение графа
        visualizer.display();
    };
    
    // ===== ГЛАВНЫЙ КОД ПРОГРАММЫ =====
    
    // Выводим красивый заголовок программы
    cout << "====================================================" << endl;
    cout << "   Программа визуализации графов (RayLib версия)  " << endl;
    cout << "            Лабораторная работа 5                  " << endl;
    cout << "====================================================" << endl;
    
    // Главный цикл программы - работает пока пользователь не выберет выход
    while (true) {
        // Выводим меню
        printMenu();
        
        // Читаем выбор пользователя
        int choice;
        cin >> choice;
        
        // Если выбран выход (0) - прерываем цикл
        if (choice == 0) {
            cout << "Выход из программы." << endl;
            break;  // Выходим из цикла while
        }
        
        // Создаём пустой граф (будет заполнен в зависимости от выбора)
        Graph graph(0);
        
        // Обрабатываем выбор пользователя
        switch (choice) {
            case 1:  // Простой граф
                cout << "\n=== Простой граф (треугольник) ===" << endl;
                graph = createSimpleGraph();  // Вызываем функцию создания
                break;
                
            case 2:  // Полный граф K5
                cout << "\n=== Полный граф K5 ===" << endl;
                graph = createCompleteGraph();
                break;
                
            case 3:  // Граф-цикл
                cout << "\n=== Граф-цикл (6 вершин) ===" << endl;
                graph = createCycleGraph();
                break;
                
            case 4:  // Двудольный граф
                cout << "\n=== Двудольный граф ===" << endl;
                graph = createBipartiteGraph();
                break;
                
            case 5:  // Несвязный граф
                cout << "\n=== Несвязный граф ===" << endl;
                graph = createDisconnectedGraph();
                break;
                
            case 6: {  // Загрузка из файла
                string filename;  // Переменная для имени файла
                cout << "Введите имя файла: ";
                cin >> filename;  // Читаем имя файла от пользователя
                // Загружаем граф из файла (статический метод класса Graph)
                graph = Graph::loadFromFile(filename);
                // Проверяем, успешно ли загрузился граф
                if (graph.getNumVertices() == 0) {
                    cout << "Не удалось загрузить граф." << endl;
                    continue;  // Возвращаемся к началу цикла (показываем меню снова)
                }
                break;
            }
                
            default:  // Неверный выбор
                cout << "Неверный выбор!" << endl;
                continue;  // Возвращаемся к началу цикла
        }
        
        // Если граф успешно создан/загружен (не пуст)
        if (graph.getNumVertices() > 0) {
            // Демонстрируем алгоритмы на графе
            demonstrateGraphAlgorithms(graph);
            
            // Визуализируем граф в окне RayLib
            visualizeGraph(graph);
        }
    }
    
    // Возвращаем 0 - успешное завершение программы
    return 0;
}
